"use strict";(self.webpackChunksystem_docs=self.webpackChunksystem_docs||[]).push([[234],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=l(t),g=s,h=p["".concat(c,".").concat(g)]||p[g]||m[g]||r;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=g;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[p]="string"==typeof e?e:s,o[1]=i;for(var l=2;l<r;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},1089:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=t(7462),s=(t(7294),t(3905));const r={sidebar_position:5},o="Chats and messages",i={unversionedId:"implementation/chats-and-messages",id:"implementation/chats-and-messages",title:"Chats and messages",description:"If organizer is waiting for a new chat and there is a chat request in agency's queue, chat starts for both the organizer",source:"@site/docs/implementation/5-chats-and-messages.md",sourceDirName:"implementation",slug:"/implementation/chats-and-messages",permalink:"/esme/docs/implementation/chats-and-messages",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docSidebar",previous:{title:"Requests for help",permalink:"/esme/docs/implementation/requests-for-help"},next:{title:"Issues and comments",permalink:"/esme/docs/implementation/issues-and-comments"}},c={},l=[{value:"Frontend",id:"frontend",level:2},{value:"Backend",id:"backend",level:2},{value:"Chat protocol",id:"chat-protocol",level:3},{value:"Messages to server",id:"messages-to-server",level:4},{value:"Messages to client",id:"messages-to-client",level:4},{value:"WebSocket connections",id:"websocket-connections",level:3},{value:"Single connection handlers",id:"single-connection-handlers",level:4},{value:"Multiple user connections",id:"multiple-user-connections",level:4},{value:"Message consumers",id:"message-consumers",level:4}],d={toc:l},p="wrapper";function m(e){let{components:n,...r}=e;return(0,s.kt)(p,(0,a.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"chats-and-messages"},"Chats and messages"),(0,s.kt)("p",null,"If organizer is waiting for a new chat and there is a chat request in agency's queue, chat starts for both the organizer\nand participant with problem description sent as the first message from the participant."),(0,s.kt)("h2",{id:"frontend"},"Frontend"),(0,s.kt)("p",null,"For better user experience, receiving a message, resizing the window or opening software keyboard on mobile devices\nautomatically scrolls the messages window to the last message."),(0,s.kt)("p",null,"If participant shares the location of his device, Organizer UI shows iframe with Google Maps centered at the participant\nlocation coordinates rounded to 5 significant digits (rounding adds uncertainty of 1.11 meters). The location is saved\nwith every participant's message and the Google Maps iframe is refreshed if the rounded coordinates change in the next\nmessage."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"organizer new chat",src:t(8056).Z,width:"1764",height:"1058"})),(0,s.kt)("p",null,"When the organizer is sure the case is resolved and chat is no longer needed, he can use the ",(0,s.kt)("strong",{parentName:"p"},"Close chat")," button\nto end it and move it to Archives section for both parties. After the chat has ended, no more messages can be sent to it\nand the chat input is hidden in both user interfaces. Closing chat releases the participant's lock on requesting help on\nthe associated event so he can later request another chat on the same event."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"organizer archives",src:t(2906).Z,width:"1760",height:"988"})),(0,s.kt)("p",null,"Mobile chats screen displays both active and archived chats and distinguishes them by bolder font and green badge for\nthe active chats. The list of chats is split by the activity status (active first) and each group is sorted by the start\ntime (newest first)."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"participant chats",src:t(3701).Z,width:"907",height:"951"})),(0,s.kt)("p",null,"What is more, if the WebSocket connection is interrupted on the frontend, both Organizer and Participant UIs are\nautomatically reconnecting every 5 seconds using React ",(0,s.kt)("inlineCode",{parentName:"p"},"useEffect")," hook and JavaScript ",(0,s.kt)("inlineCode",{parentName:"p"},"setInterval"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"useEffect(() => {\n    if (messenger.hasState() && !messenger.isConnected()) {\n        const restartInterval = setInterval(\n            () => messenger.connect(\n                authorizationHeader,\n                dispatch,\n                alertStore\n            ),\n            restartIntervalTime\n        )\n        return () => clearTimeout(restartInterval)\n    }\n}, [messenger.hasState(), messenger.isConnected()])\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"messenger")," object in the above code is an instance of a class managing client WebSocket connection to\nMessenger API. It additionally uses authorization header to authenticate, integrates ",(0,s.kt)("inlineCode",{parentName:"p"},"dispatch")," function from\n",(0,s.kt)("inlineCode",{parentName:"p"},"useReducer")," hook handling incoming messages from the server and signals connection errors in the application\nalert bar with ",(0,s.kt)("inlineCode",{parentName:"p"},"alertStore")," object."),(0,s.kt)("p",null,"To make the WebSocket easily accessible in any React component that needs it, two contexts has been created:\n",(0,s.kt)("inlineCode",{parentName:"p"},"InboxContext")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"MessengerContext"),". The first one stores user chats and messages (with participant's\ngeolocation information in case of Organizer UI) and the latter exposes methods to send WebSocket messages to the\nMessenger API."),(0,s.kt)("h2",{id:"backend"},"Backend"),(0,s.kt)("h3",{id:"chat-protocol"},"Chat protocol"),(0,s.kt)("p",null,"Messenger API uses custom JSON-based chat protocol for incoming and outgoing messages in the form of:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'{\n  "type": <message_type:string>,\n  "payload": <data:any>\n}\n')),(0,s.kt)("p",null,"The only exception is the first message from client, which is a JSON with authorization header as the browser WebSocket\nimplementation does not support sending a HTTP header while establishing connection. ",(0,s.kt)("inlineCode",{parentName:"p"},"Authorization")," is not a\nrequired opening handshake header in the ",(0,s.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc6455#section-4"},"RFC 6455")," defining\nthe WebSocket Protocol."),(0,s.kt)("p",null,"After successfully connecting to the server, client implementations in React and React Native start with sending the\n",(0,s.kt)("inlineCode",{parentName:"p"},"get_chats")," and then sending ",(0,s.kt)("inlineCode",{parentName:"p"},"get_chat_history")," for each returned chat."),(0,s.kt)("h4",{id:"messages-to-server"},"Messages to server"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Message type"),(0,s.kt)("th",{parentName:"tr",align:null},"Data"),(0,s.kt)("th",{parentName:"tr",align:null},"Users allowed to send"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"get_chats")),(0,s.kt)("td",{parentName:"tr",align:null},"none"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"get_chat_history")),(0,s.kt)("td",{parentName:"tr",align:null},"chat id"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"send_message")),(0,s.kt)("td",{parentName:"tr",align:null},"chat id and message text"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"start_chat")),(0,s.kt)("td",{parentName:"tr",align:null},"none"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"close_chat")),(0,s.kt)("td",{parentName:"tr",align:null},"chat id"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers")))),(0,s.kt)("p",null,"All users can use ",(0,s.kt)("inlineCode",{parentName:"p"},"send_message")," action to communicate, but only the organizers have access to\n",(0,s.kt)("inlineCode",{parentName:"p"},"start_chat")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"close_chat")," actions to manage their active chats."),(0,s.kt)("h4",{id:"messages-to-client"},"Messages to client"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Message type"),(0,s.kt)("th",{parentName:"tr",align:null},"Data"),(0,s.kt)("th",{parentName:"tr",align:null},"Users allowed to receive"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"chats")),(0,s.kt)("td",{parentName:"tr",align:null},"list of chats"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"chat_history")),(0,s.kt)("td",{parentName:"tr",align:null},"chat id and list of messages"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"user_message")),(0,s.kt)("td",{parentName:"tr",align:null},"message"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"new_chat")),(0,s.kt)("td",{parentName:"tr",align:null},"chat"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"closed_chat")),(0,s.kt)("td",{parentName:"tr",align:null},"chat"),(0,s.kt)("td",{parentName:"tr",align:null},"organizers and participants")))),(0,s.kt)("h3",{id:"websocket-connections"},"WebSocket connections"),(0,s.kt)("h4",{id:"single-connection-handlers"},"Single connection handlers"),(0,s.kt)("p",null,"User's ",(0,s.kt)("strong",{parentName:"p"},"connection handler")," is running in its own goroutine with a for loop reading incoming messages from a specific\nWebSocket connection of the user and it exposes methods for sending an outgoing message or an error there. To\nsynchronize actions between all connections from the user (they could be from different devices or browser tabs),\n",(0,s.kt)("strong",{parentName:"p"},"connection handler")," uses a Golang channel to push all the messages to the user's ",(0,s.kt)("strong",{parentName:"p"},"connection pool\nhandler"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'func (oc *OrganizerConnection) listenOnConnection() {\n  defer func() {\n    if r := recover(); r != nil {\n      oc.logger.Printf("panic %v\\n", r)\n      oc.Close()\n      return\n    }\n  }()\n  \n  for {\n    msg, err := oc.read()\n    if err != nil {\n      if !oc.handleReadError(err) {\n        return\n      }\n      continue\n    }\n\n    oc.resetReadTimer()\n    oc.messages <- NewOrganizerMessage(msg, oc)\n  }\n}\n\nfunc (oc *OrganizerConnection) read() (*protocol.Message, error) {\n    msg := &protocol.Message{}\n    return msg, oc.wsConnection.ReadJSON(msg)\n}\n')),(0,s.kt)("h4",{id:"multiple-user-connections"},"Multiple user connections"),(0,s.kt)("p",null,"User's ",(0,s.kt)("strong",{parentName:"p"},"connection pool handler")," exposes thread-safe methods (protected by a mutex) for adding a new WebSocket\nconnection and for outgoing message fan-out to all user connections. Additionally, it uses two goroutines with for loops\nto listen for incoming messages and to listen for connection shutdowns. When all the user connections are closed,\n",(0,s.kt)("strong",{parentName:"p"},"connection pool handler")," starts a graceful shutdown of itself to free memory. Golang channels and select\nstatements are used to notify and stop hanging goroutines."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'func (ocp *OrganizerConnectionPool) listenOnMessages() {\n  for {\n    select {\n    case <-ocp.doneChan:\n      ocp.logger.Printf(\n        "stopped listening on messages for %s\\n", \n        ocp.GetInfo(),\n      )\n      return\n    case msg := <-ocp.connectionMessages:\n      go ocp.consumer.ConsumeMessage(msg)\n    }\n  }\n}\n\nfunc (ocp *OrganizerConnectionPool) listenOnShutdowns() {\n  for {\n    select {\n    case <-ocp.doneChan:\n      ocp.logger.Printf(\n        "stopped listening on shutdowns for %s\\n", \n        ocp.GetInfo(),\n      )\n      return\n    case conn := <-ocp.connectionShutdowns:\n      go ocp.removeConnection(conn)\n    }\n  }\n}\n')),(0,s.kt)("h4",{id:"message-consumers"},"Message consumers"),(0,s.kt)("p",null,"The incoming messages consumers expose a ",(0,s.kt)("inlineCode",{parentName:"p"},"ConsumeMessage")," method to appropriately handle each message type.\nOrganizer and participant messages are handled by similar consumers with a few differences in allowed message types and\nlogic. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'func (c *Consumer) ConsumeMessage(msg *connections.OrganizerMessage) {\n  switch msg.Message.Type {\n  case in.MsgTypeGetChats:\n    c.consumeGetChats(msg)\n  case in.MsgTypeStartChat:\n    c.consumeStartChat(msg)\n  case in.MsgTypeSendMessage:\n    c.consumeSendMessage(msg)\n  case in.MsgTypeGetChatHistory:\n    c.consumeGetChatHistory(msg)\n  case in.MsgTypeCloseChat:\n    c.consumeCloseChat(msg)\n  default:\n    c.logger.Printf(\n      "invalid message type %s from organizer %d\\n",\n      msg.Message.Type, \n      msg.Source.Organizer.Id,\n    )\n    msg.Source.SendError(common.ErrInvalidMessageType)\n  }\n}\n')),(0,s.kt)("p",null,"Incoming message consumers use a reference to ",(0,s.kt)("inlineCode",{parentName:"p"},"ChatsManager")," which coordinates sending outgoing messages to\nmembers of the specific chat and provides in-memory cache with active chats. To ensure that server state is up to date,\ninitializing a new WebSocket connection goes through the ",(0,s.kt)("inlineCode",{parentName:"p"},"ChatsManager")," which fetches user chats and then creates\nor calls an existing user's ",(0,s.kt)("strong",{parentName:"p"},"connection pool handler")," to attach a new ",(0,s.kt)("strong",{parentName:"p"},"connection handler"),". Unfortunately,\nthis design is stateful and does not allow horizontal scalability because it assumes that all WebSocket connections\ncommunicate with the same chat server keeping all active chats and connection pools."))}m.isMDXComponent=!0},2906:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/messenger_archives-752d8ceb66ded0368ad6c0595a448955.png"},8056:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/messenger_new_chat-15bb42e4985cb4d2d09477f4be2cfe71.png"},3701:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/messenger_participant_chats-d69d4daf2d62e7e44fb023f8f2c1f659.png"}}]);